{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introducing Squirrels A Python API framework for generating dynamic queries for analytics. Squirrels is an API framework for creating APIs that generate SQL queries & dataframes dynamically from query parameters. Start by reading through Tutorial pages. Or check out the Overview page for understanding the framework. Why the name \"squirrels\"? \"Squirrels\" stands for \" S tructured QU ery I nterface with R ealtime R endering and E laborate L anguage S ynchronization\". The current \"languages\" include SQL and Python. It's also called \"squirrels\" for the following reasons: \"SQURL\" was also considered as a name for the framework, which is short for \"SQL URL\". This sounds like \"squirrel\" Following the theme of using animal names (plural form) for useful Python packages (like \"pandas\")","title":"Home"},{"location":"#introducing-squirrels","text":"A Python API framework for generating dynamic queries for analytics. Squirrels is an API framework for creating APIs that generate SQL queries & dataframes dynamically from query parameters. Start by reading through Tutorial pages. Or check out the Overview page for understanding the framework.","title":"Introducing Squirrels"},{"location":"#why-the-name-squirrels","text":"\"Squirrels\" stands for \" S tructured QU ery I nterface with R ealtime R endering and E laborate L anguage S ynchronization\". The current \"languages\" include SQL and Python. It's also called \"squirrels\" for the following reasons: \"SQURL\" was also considered as a name for the framework, which is short for \"SQL URL\". This sounds like \"squirrel\" Following the theme of using animal names (plural form) for useful Python packages (like \"pandas\")","title":"Why the name \"squirrels\"?"},{"location":"overview/","text":"Overview","title":"Overview"},{"location":"overview/#overview","text":"","title":"Overview"},{"location":"tutorial/","text":"Tutorial An introductory tutorial for Squirrels. Installation First, create and activate a virtual environment for your squirrels project (see Python's venv for reference). To install the squirrels library in your virtual environment, simply run: pip install squirrels Initialize a New Project You can initialize the project files using: squirrels init Prompts will appear for the various files you wish to include in your project. Answer the prompts as follows: [?] Include all core project files? (Y/n): y [?] Do you want to include a 'context.py' file? (y/N): y [?] Do you want to include a 'selections.cfg' file? (y/N): n [?] What's the file format for the database view? (ignore if core project files are not included): sql > sql py [?] What's the file format for the final view (if any)?: sql > none sql py [?] What sample sqlite database do you wish to use (if any)?: seattle_weather none sample_database > seattle_weather Once the command is executed, the following files are created. This includes: .gitignore , project_vars.yaml , connections.py , requirements.txt , and squirrels.yaml at the project root parameters.py , context.py and database_view.sql.j2 in the datasets/sample_dataset subfolder seattle_weather.db sqlite database in the database folder For more details, see docs for the [init CLI]. Provide the Database Connection Next, create a squirrels database connection key. To do this, go in the connections.py file, and change the sqlalchemy url to the seattle_weather.db database. In the return statement, you may change the my_db key to a new name of your choice for the database connection key. For the rest of this tutorial, we will assume the profile name is sqlite_db . At this point, your connections.py file should look something like this (ignoring comments). from typing import Dict from sqlalchemy import create_engine, QueuePool from squirrels import ConnectionSet, get_credential def main(proj: Dict[str, str], *args, **kwargs) -> ConnectionSet: pool = create_engine('sqlite:///./database/seattle_weather.db') return ConnectionSet({'sqlite_db': pool}) In the squirrels.yaml file, set the db_connection to sqlite_db . Configure a Dataset In the squirrels.yaml file, set the product property under project_variables to seattle_weather . Replace the sample_dataset field (under datasets ) with weather_by_time . Specify the following values under the weather_by_time field: Set label to Weather by Time of Year Set name (under database_views ) to weather_by_time Set file (under database_views ) to weather_by_time.sql.j2 Set final_view to final_view.sql.j2 At this point in time, your squirrels.yaml file should look something like this: project_variables: product: seattle_weather major_version: '0' minor_version: '1' modules: [] db_profile: myprofile base_path: \"/{{product}}/v{{major_version}}\" datasets: weather_by_time: label: Weather by Time of Year database_views: - name: weather_by_time file: weather_by_time.sql.j2 final_view: weather_by_time settings: {} Rename the following files/folders to reflect the changes you made in the squirrels.yaml file. Rename datasets/sample_dataset to datasets/weather_by_time Rename datasets/weather_by_time/database_view1.sql.j2 to datasets/weather_by_time/weather_by_time.sql.j2 Create the Parameters In the datasets/weather_by_time/ folder, there's a parameters.py file to specify the parameters for the weather_by_time dataset. Replace the contents of the parameters.py file with the following. from typing import Dict import squirrels as sq class GroupByOption(sq.ParameterOption): def __init__(self, id, label, dim_col, order_by_col = None): super().__init__(id, label) self.dim_col = dim_col self.order_by_col = order_by_col if order_by_col is not None else dim_col group_by_options = [ GroupByOption('0', 'Year', 'year'), GroupByOption('1', 'Quarter', 'quarter'), GroupByOption('2', 'Month', 'month_name', 'month_order'), GroupByOption('3', 'Day of Year', 'day_of_year'), GroupByOption('4', 'Condition', 'condition') ] def main() -> Dict[str, sq.Parameter]: return { 'group_by': sq.SingleSelectParameter('Group By', group_by_options), } Classes like ParameterOption , Parameter , and SingleSelectParameter are provided by the squirrels framework. In the code above, we extend from the existing ParameterOption class to create our own class with additional attributes. We will be able to use these attributes in the SQL query templates we define later. The parameters.py file must specify a main() function that returns a dictionary of parameter names (as keys) to parameter objects (as value). In the code above, we specified one single-select parameter called group_by which will affect the dimension column used for aggregating in the SQL query. Create the Dynamic SQL Query In the datasets/weather_by_time/ folder, replace the contents of the weather_by_time.sql.j2 file with the following. {% set selected_group_by = prms('group_by').get_selected() -%} {% set dim_col = selected_group_by.dim_col -%} {% set order_col = selected_group_by.order_by_col -%} SELECT {{ dim_col }} , avg(temp_max) as temperature_high_C , avg(temp_min) as temperature_low_C , avg(precipitation) as precipitation_inches , avg(wind) as wind_mph FROM weather GROUP BY {{ dim_col }}, {{ order_col }} ORDER BY {{ order_col }} The lines written like {% set ... -%} uses Jinja2 syntax to create variables for the templated SQL to use. The prms function is available to retrieve a Parameter object, and for SingleSelectParameter's, the .get_selected() method is available to retrieve the selected ParameterOption, which we extended as a GroupByOption. Thus, the dim_col and order_by_col attributes are available on the GroupByOption. Note that this example only uses one \"database view\", and the \"final view\" does not apply any further transformations. For more complex use cases, you can also write Jinja2 templated SQL or Python files for the final view as well to process on the API server from the results of one or more database views. In addition, this framework also lets you define the dim_col and order_col variables through Python instead of through the Jinja template. Test the Generated Output You can test the output of the generated SQL query and parameters response for the default parameter selections of the weather_by_time dataset by running: squirrels test weather_by_time This creates a outputs/weather_by_time subfolder with the generated SQL query without running it yet. Confirm all outputs look as expected. You can also run the following to generate all database views and final view results as csv files. squirrels test weather_by_time --runquery You can also test on non-default parameter selections. Run the API Server Run the following CLI command to activate the API server in \"debug mode\": squirrels run --debug You should now be able to access the following APIs. http://localhost:8000/squirrels0/seattle-weather/v0 Catalog of the parameters and results APIs for each dataset http://localhost:8000/squirrels0/seattle-weather/v0/weather-by-time/parameters All the parameters information for the dataset http://localhost:8000/squirrels0/seattle-weather/v0/weather-by-time The results of the dataset using the default value for each parameter For a simple UI to test the API interactions, go to http://localhost:8000/ from your browser.","title":"Tutorial"},{"location":"tutorial/#tutorial","text":"An introductory tutorial for Squirrels.","title":"Tutorial"},{"location":"tutorial/#installation","text":"First, create and activate a virtual environment for your squirrels project (see Python's venv for reference). To install the squirrels library in your virtual environment, simply run: pip install squirrels","title":"Installation"},{"location":"tutorial/#initialize-a-new-project","text":"You can initialize the project files using: squirrels init Prompts will appear for the various files you wish to include in your project. Answer the prompts as follows: [?] Include all core project files? (Y/n): y [?] Do you want to include a 'context.py' file? (y/N): y [?] Do you want to include a 'selections.cfg' file? (y/N): n [?] What's the file format for the database view? (ignore if core project files are not included): sql > sql py [?] What's the file format for the final view (if any)?: sql > none sql py [?] What sample sqlite database do you wish to use (if any)?: seattle_weather none sample_database > seattle_weather Once the command is executed, the following files are created. This includes: .gitignore , project_vars.yaml , connections.py , requirements.txt , and squirrels.yaml at the project root parameters.py , context.py and database_view.sql.j2 in the datasets/sample_dataset subfolder seattle_weather.db sqlite database in the database folder For more details, see docs for the [init CLI].","title":"Initialize a New Project"},{"location":"tutorial/#provide-the-database-connection","text":"Next, create a squirrels database connection key. To do this, go in the connections.py file, and change the sqlalchemy url to the seattle_weather.db database. In the return statement, you may change the my_db key to a new name of your choice for the database connection key. For the rest of this tutorial, we will assume the profile name is sqlite_db . At this point, your connections.py file should look something like this (ignoring comments). from typing import Dict from sqlalchemy import create_engine, QueuePool from squirrels import ConnectionSet, get_credential def main(proj: Dict[str, str], *args, **kwargs) -> ConnectionSet: pool = create_engine('sqlite:///./database/seattle_weather.db') return ConnectionSet({'sqlite_db': pool}) In the squirrels.yaml file, set the db_connection to sqlite_db .","title":"Provide the Database Connection"},{"location":"tutorial/#configure-a-dataset","text":"In the squirrels.yaml file, set the product property under project_variables to seattle_weather . Replace the sample_dataset field (under datasets ) with weather_by_time . Specify the following values under the weather_by_time field: Set label to Weather by Time of Year Set name (under database_views ) to weather_by_time Set file (under database_views ) to weather_by_time.sql.j2 Set final_view to final_view.sql.j2 At this point in time, your squirrels.yaml file should look something like this: project_variables: product: seattle_weather major_version: '0' minor_version: '1' modules: [] db_profile: myprofile base_path: \"/{{product}}/v{{major_version}}\" datasets: weather_by_time: label: Weather by Time of Year database_views: - name: weather_by_time file: weather_by_time.sql.j2 final_view: weather_by_time settings: {} Rename the following files/folders to reflect the changes you made in the squirrels.yaml file. Rename datasets/sample_dataset to datasets/weather_by_time Rename datasets/weather_by_time/database_view1.sql.j2 to datasets/weather_by_time/weather_by_time.sql.j2","title":"Configure a Dataset"},{"location":"tutorial/#create-the-parameters","text":"In the datasets/weather_by_time/ folder, there's a parameters.py file to specify the parameters for the weather_by_time dataset. Replace the contents of the parameters.py file with the following. from typing import Dict import squirrels as sq class GroupByOption(sq.ParameterOption): def __init__(self, id, label, dim_col, order_by_col = None): super().__init__(id, label) self.dim_col = dim_col self.order_by_col = order_by_col if order_by_col is not None else dim_col group_by_options = [ GroupByOption('0', 'Year', 'year'), GroupByOption('1', 'Quarter', 'quarter'), GroupByOption('2', 'Month', 'month_name', 'month_order'), GroupByOption('3', 'Day of Year', 'day_of_year'), GroupByOption('4', 'Condition', 'condition') ] def main() -> Dict[str, sq.Parameter]: return { 'group_by': sq.SingleSelectParameter('Group By', group_by_options), } Classes like ParameterOption , Parameter , and SingleSelectParameter are provided by the squirrels framework. In the code above, we extend from the existing ParameterOption class to create our own class with additional attributes. We will be able to use these attributes in the SQL query templates we define later. The parameters.py file must specify a main() function that returns a dictionary of parameter names (as keys) to parameter objects (as value). In the code above, we specified one single-select parameter called group_by which will affect the dimension column used for aggregating in the SQL query.","title":"Create the Parameters"},{"location":"tutorial/#create-the-dynamic-sql-query","text":"In the datasets/weather_by_time/ folder, replace the contents of the weather_by_time.sql.j2 file with the following. {% set selected_group_by = prms('group_by').get_selected() -%} {% set dim_col = selected_group_by.dim_col -%} {% set order_col = selected_group_by.order_by_col -%} SELECT {{ dim_col }} , avg(temp_max) as temperature_high_C , avg(temp_min) as temperature_low_C , avg(precipitation) as precipitation_inches , avg(wind) as wind_mph FROM weather GROUP BY {{ dim_col }}, {{ order_col }} ORDER BY {{ order_col }} The lines written like {% set ... -%} uses Jinja2 syntax to create variables for the templated SQL to use. The prms function is available to retrieve a Parameter object, and for SingleSelectParameter's, the .get_selected() method is available to retrieve the selected ParameterOption, which we extended as a GroupByOption. Thus, the dim_col and order_by_col attributes are available on the GroupByOption. Note that this example only uses one \"database view\", and the \"final view\" does not apply any further transformations. For more complex use cases, you can also write Jinja2 templated SQL or Python files for the final view as well to process on the API server from the results of one or more database views. In addition, this framework also lets you define the dim_col and order_col variables through Python instead of through the Jinja template.","title":"Create the Dynamic SQL Query"},{"location":"tutorial/#test-the-generated-output","text":"You can test the output of the generated SQL query and parameters response for the default parameter selections of the weather_by_time dataset by running: squirrels test weather_by_time This creates a outputs/weather_by_time subfolder with the generated SQL query without running it yet. Confirm all outputs look as expected. You can also run the following to generate all database views and final view results as csv files. squirrels test weather_by_time --runquery You can also test on non-default parameter selections.","title":"Test the Generated Output"},{"location":"tutorial/#run-the-api-server","text":"Run the following CLI command to activate the API server in \"debug mode\": squirrels run --debug You should now be able to access the following APIs. http://localhost:8000/squirrels0/seattle-weather/v0 Catalog of the parameters and results APIs for each dataset http://localhost:8000/squirrels0/seattle-weather/v0/weather-by-time/parameters All the parameters information for the dataset http://localhost:8000/squirrels0/seattle-weather/v0/weather-by-time The results of the dataset using the default value for each parameter For a simple UI to test the API interactions, go to http://localhost:8000/ from your browser.","title":"Run the API Server"},{"location":"cli/credentials/","text":"","title":"credential management"},{"location":"cli/init/","text":"","title":"init"},{"location":"cli/load-modules/","text":"","title":"load-modules"},{"location":"cli/run/","text":"","title":"run"},{"location":"cli/test/","text":"","title":"test"},{"location":"how-to/common-vary/","text":"Design for Commonality and Variability","title":"Design for Commonality and Variability"},{"location":"how-to/common-vary/#design-for-commonality-and-variability","text":"","title":"Design for Commonality and Variability"},{"location":"how-to/database/","text":"Configure Database Connections","title":"Configure Database Connections"},{"location":"how-to/database/#configure-database-connections","text":"","title":"Configure Database Connections"},{"location":"how-to/python-views/","text":"Create Views with Python","title":"Create Views with Python"},{"location":"how-to/python-views/#create-views-with-python","text":"","title":"Create Views with Python"},{"location":"how-to/sql-views/","text":"Create Views with SQL and Jinja","title":"Create Views with SQL and Jinja"},{"location":"how-to/sql-views/#create-views-with-sql-and-jinja","text":"","title":"Create Views with SQL and Jinja"},{"location":"tutorial/context/","text":"Use the Context File Let's revisit the SQL/Jinja files. In both files, we use prms[\"group_by\"].get_selected() to get the selected parameter option from the group_by parameters, and access the dim_col attribute from the object. Doing all this in a SQL/Jinja file can be a poor developer experience, especially if you're using an IDE that can provide auto-completion for Python files. Instead, we can use the context.py file to improve the developer experience. We use its main function to transform all selected parameter options into useful values (usually strings) returned as dictionary values. Then, in the SQL/Jinja files, the dictionary can be referenced using the ctx keyword. For example, we can update the context.py file contents to look like this: from typing import Dict, Any import squirrels as sq from datasets.weather_by_time.parameters import GroupByOption def main(prms: sq.ParameterSet, args: Dict[str, Any], *p_args, **kwargs) -> Dict[str, Any]: group_by_param: sq.SingleSelectParameter = prms[\"group_by\"] selected_group_by: GroupByOption = group_by_param.get_selected() return { \"dim_col\": selected_group_by.dim_col, \"order_col\": selected_group_by.order_by_col } Notice that type hints were added for variables group_by_param and selected_group_by . This is useful to provide the IDE information on suggesting methods to auto-complete. For instance, with a list of suggestions, we don't have to memorize that the .get_selected() method exists for SingleSelectParameter objects to get the selected parameter option, or memorize what the method names would be for other parameter classes. Auto-completion would allow these methods to be discovered more easily. Now the SQL queries can be written more concisely to reference the context variables instead. The contents for aggr_weather_metrics.sql.j2 can now be changed to the following. SELECT {{ ctx[\"dim_col\"] }} , {{ ctx[\"order_col\"] }} as ordering , avg(temp_max) as temperature_high_C , avg(temp_min) as temperature_low_C , avg(precipitation) as precipitation_inches , avg(wind) as wind_mph FROM weather GROUP BY {{ ctx[\"dim_col\"] }}, {{ ctx[\"order_col\"] }} In addition, the contents for final_view.sql.j2 can now be changed to the following. SELECT {{ ctx[\"dim_col\"] }} , temperature_high_C , temperature_low_C , precipitation_inches , wind_mph FROM aggregate_weather_metrics ORDER BY ordering Final Thoughts A Squirrels project may also contain multiple datasets, or datasets with multiple database views, but that's outside the scope of this tutorial. For an expanded version of the \"seattle weather example\" project, see this git repo here . It serves as an example of how to share common Python code or SQL across multiple datasets while allowing their parameters or query definitions to not be identical. You can also eee this page for how to \" Design for Commonality and Variability \".","title":"6. Use the Context File"},{"location":"tutorial/context/#use-the-context-file","text":"Let's revisit the SQL/Jinja files. In both files, we use prms[\"group_by\"].get_selected() to get the selected parameter option from the group_by parameters, and access the dim_col attribute from the object. Doing all this in a SQL/Jinja file can be a poor developer experience, especially if you're using an IDE that can provide auto-completion for Python files. Instead, we can use the context.py file to improve the developer experience. We use its main function to transform all selected parameter options into useful values (usually strings) returned as dictionary values. Then, in the SQL/Jinja files, the dictionary can be referenced using the ctx keyword. For example, we can update the context.py file contents to look like this: from typing import Dict, Any import squirrels as sq from datasets.weather_by_time.parameters import GroupByOption def main(prms: sq.ParameterSet, args: Dict[str, Any], *p_args, **kwargs) -> Dict[str, Any]: group_by_param: sq.SingleSelectParameter = prms[\"group_by\"] selected_group_by: GroupByOption = group_by_param.get_selected() return { \"dim_col\": selected_group_by.dim_col, \"order_col\": selected_group_by.order_by_col } Notice that type hints were added for variables group_by_param and selected_group_by . This is useful to provide the IDE information on suggesting methods to auto-complete. For instance, with a list of suggestions, we don't have to memorize that the .get_selected() method exists for SingleSelectParameter objects to get the selected parameter option, or memorize what the method names would be for other parameter classes. Auto-completion would allow these methods to be discovered more easily. Now the SQL queries can be written more concisely to reference the context variables instead. The contents for aggr_weather_metrics.sql.j2 can now be changed to the following. SELECT {{ ctx[\"dim_col\"] }} , {{ ctx[\"order_col\"] }} as ordering , avg(temp_max) as temperature_high_C , avg(temp_min) as temperature_low_C , avg(precipitation) as precipitation_inches , avg(wind) as wind_mph FROM weather GROUP BY {{ ctx[\"dim_col\"] }}, {{ ctx[\"order_col\"] }} In addition, the contents for final_view.sql.j2 can now be changed to the following. SELECT {{ ctx[\"dim_col\"] }} , temperature_high_C , temperature_low_C , precipitation_inches , wind_mph FROM aggregate_weather_metrics ORDER BY ordering","title":"Use the Context File"},{"location":"tutorial/context/#final-thoughts","text":"A Squirrels project may also contain multiple datasets, or datasets with multiple database views, but that's outside the scope of this tutorial. For an expanded version of the \"seattle weather example\" project, see this git repo here . It serves as an example of how to share common Python code or SQL across multiple datasets while allowing their parameters or query definitions to not be identical. You can also eee this page for how to \" Design for Commonality and Variability \".","title":"Final Thoughts"},{"location":"tutorial/initialize/","text":"Initialize a Squirrels Project You can initialize the project files using: squirrels init Prompts will appear for the various files you wish to include in your project. Answer the prompts as follows: [?] Include all core project files? (Y/n): y [?] What's the file format for the database view?: sql > sql py [?] Do you want to add a 'connections.py' file? (y/N): n [?] Do you want to add a 'context.py' file? (y/N): n [?] Do you want to add a 'selections.cfg' file? (y/N): n [?] What's the file format for the final view (if any)?: none > none sql py [?] What sample sqlite database do you wish to use (if any)?: sample_database none > sample_database seattle_weather Once the command is executed, the following files are created. .gitignore , requirements.txt , and squirrels.yaml at the project root parameters.py and database_view.sql.j2 in the datasets/sample_dataset subfolder sample_database.db sqlite database in the database folder If we exclude the sqlite database and files that are common for all Python git projects, then squirrels.yaml , parameters.py , and database_view.sql.j2 are essentially all you need to have a working squirrels project! Go ahead and take a quick glance at the new files (no need to fully understand them now). Then, run the API server using the command: squirrels run In a web browser, go to http://localhost:8000/ or http://127.0.0.1:8000/ . This leads you to the Squirrels UI, a convenient interface for testing the dataset APIs. Without changing the widget parameters, clicking \"Apply\" will show you the dataset for the default parameter selections. For now, the \"Upper Bound\" parameter is the only one that affects the dataset results. To see the API endpoints that provides the information on the parameters and tabular results on the \"Sample Dataset\", you can use the following URLs to access the JSON results for the default parameter selections: Parameters API: http://localhost:8000/squirrels0/sample/v1/sample-dataset/parameters Dataset API: http://localhost:8000/squirrels0/sample/v1/sample-dataset After you're done with the API Server, you can terminate it in the terminal using ctrl-c . Now, we will use the init command again to add more files that'll come in handy for the rest of the tutorial. Run: squirrels init --context --selections-cfg --final-view sql --sample-db seattle_weather The following files have been added. context.py , final_view.sql.j2 , and selections.cfg in the datasets/sample_dataset subfolder seattle_weather.db sqlite database in the database folder Note that when specifying command line arguments to squirrels init , the prompt no longer show up. You can see squirrels init --help for more details on what various command line arguments do. Currently, all arguments except \"--help\" and \"--overwrite\" disables the prompts.","title":"1. Initialize a Squirrels Project"},{"location":"tutorial/initialize/#initialize-a-squirrels-project","text":"You can initialize the project files using: squirrels init Prompts will appear for the various files you wish to include in your project. Answer the prompts as follows: [?] Include all core project files? (Y/n): y [?] What's the file format for the database view?: sql > sql py [?] Do you want to add a 'connections.py' file? (y/N): n [?] Do you want to add a 'context.py' file? (y/N): n [?] Do you want to add a 'selections.cfg' file? (y/N): n [?] What's the file format for the final view (if any)?: none > none sql py [?] What sample sqlite database do you wish to use (if any)?: sample_database none > sample_database seattle_weather Once the command is executed, the following files are created. .gitignore , requirements.txt , and squirrels.yaml at the project root parameters.py and database_view.sql.j2 in the datasets/sample_dataset subfolder sample_database.db sqlite database in the database folder If we exclude the sqlite database and files that are common for all Python git projects, then squirrels.yaml , parameters.py , and database_view.sql.j2 are essentially all you need to have a working squirrels project! Go ahead and take a quick glance at the new files (no need to fully understand them now). Then, run the API server using the command: squirrels run In a web browser, go to http://localhost:8000/ or http://127.0.0.1:8000/ . This leads you to the Squirrels UI, a convenient interface for testing the dataset APIs. Without changing the widget parameters, clicking \"Apply\" will show you the dataset for the default parameter selections. For now, the \"Upper Bound\" parameter is the only one that affects the dataset results. To see the API endpoints that provides the information on the parameters and tabular results on the \"Sample Dataset\", you can use the following URLs to access the JSON results for the default parameter selections: Parameters API: http://localhost:8000/squirrels0/sample/v1/sample-dataset/parameters Dataset API: http://localhost:8000/squirrels0/sample/v1/sample-dataset After you're done with the API Server, you can terminate it in the terminal using ctrl-c . Now, we will use the init command again to add more files that'll come in handy for the rest of the tutorial. Run: squirrels init --context --selections-cfg --final-view sql --sample-db seattle_weather The following files have been added. context.py , final_view.sql.j2 , and selections.cfg in the datasets/sample_dataset subfolder seattle_weather.db sqlite database in the database folder Note that when specifying command line arguments to squirrels init , the prompt no longer show up. You can see squirrels init --help for more details on what various command line arguments do. Currently, all arguments except \"--help\" and \"--overwrite\" disables the prompts.","title":"Initialize a Squirrels Project"},{"location":"tutorial/installation/","text":"Installation First, create and activate a virtual environment for your squirrels project (see python virtual environments for reference). To install the squirrels library in your virtual environment, simply run: pip install squirrels","title":"Installation"},{"location":"tutorial/installation/#installation","text":"First, create and activate a virtual environment for your squirrels project (see python virtual environments for reference). To install the squirrels library in your virtual environment, simply run: pip install squirrels","title":"Installation"},{"location":"tutorial/manifest/","text":"Configure the Manifest File Go to the squirrels.yaml file. This is the manifest file to configure most of the properties of the Squirrels project. In this tutorial, we will focus on the project_variables , db_connections , and datasets sections. We will also assume that all comments in the yaml file (every '#' to end of line) are removed. Setting the Project Variables The project variables product , major_version , and minor_version are required. In additional to those, you are free to add any of your own project variable. In this tutorial, we will be making dataset APIs related to historical weather data in Seattle. Change the product to seattle_weather . We can leave major_version and minor_version unchanged. The project_variables section should now look like this: project_variables: product: seattle_weather major_version: 1 minor_version: 0 Setting the Database Connections This section is where we set all the database connection details that we need. We provide a list of connection names here and refer to them in other files. The connection name default must be provided for database views (and DataSourceParameter , which will be mentioned later) that don't specify a connection name explicitly. Under default , change the url from sqlite://${username}:${password}@/./database/sample_database.db to sqlite:///./database/seattle_weather.db . The syntax for the URL uses sqlalchemy database URLs . Since sqlite databases don't require a username and password, the credential_key field can be omitted. More details on setting and using credential keys can be found on the pages for \" credential management \" command line reference and how to \" Configure Database Connections \". The db_connections section should now look like this: db_connections: default: url: 'sqlite:///./database/seattle_weather.db' Note The db_connections section is optional if you choose to set the connection details in Python with a connections.py file or if your squirrels project doesn't require any database connections. More details can be found on the \" Configure Database Connections \" page. Defining the Datasets This section is where we define the attributes for all datasets created by the squirrels project. Every dataset defined will have their own \"parameters API\" and \"dataset API\". Currently, there is one dataset with the name sample_dataset (and label Sample Dataset ). Change the name to weather_by_time , and change the label to Weather by Time of Year . Every dataset defined would have 0 or more database_views and exactly 1 final_view . Each of the database_views / final_view can either be A string for the file name of the SQL file (templated with Jinja ) or Python file to run, or An object with the file key and additional optional keys such as db_connection and args . In addition to being a templated SQL or Python file, the final_view can also be the name of one of the database views. Note At runtime, all the database views for the dataset are run in parallel. If the final view is a SQL file, all the database view results are loaded into an in-memory sqlite database where the table names are the same as the database view names. If the final view is a Python file, the database view results are accessible as a dictionary of database view names to pandas Dataframes. More details on writing final views will come later in the tutorial. Change the name database_view1 to aggregate_weather_metrics , and replace its value from an object to the string aggr_weather_metrics.sql.j2 . Change the value of final_view to final_view.sql.j2 . You may also remove the optional args key to the weather_by_time dataset. The datasets section should now look like this: datasets: weather_by_time: label: Weather by Time of Year database_views: aggregate_weather_metrics: aggr_weather_metrics.sql.j2 final_view: final_view.sql.j2 Every dataset that's set in the datasets section must also have a matching folder name in datasets folder. In the datasets folder, rename sample_dataset to weather_by_time .","title":"2. Configure the Manifest File"},{"location":"tutorial/manifest/#configure-the-manifest-file","text":"Go to the squirrels.yaml file. This is the manifest file to configure most of the properties of the Squirrels project. In this tutorial, we will focus on the project_variables , db_connections , and datasets sections. We will also assume that all comments in the yaml file (every '#' to end of line) are removed.","title":"Configure the Manifest File"},{"location":"tutorial/manifest/#setting-the-project-variables","text":"The project variables product , major_version , and minor_version are required. In additional to those, you are free to add any of your own project variable. In this tutorial, we will be making dataset APIs related to historical weather data in Seattle. Change the product to seattle_weather . We can leave major_version and minor_version unchanged. The project_variables section should now look like this: project_variables: product: seattle_weather major_version: 1 minor_version: 0","title":"Setting the Project Variables"},{"location":"tutorial/manifest/#setting-the-database-connections","text":"This section is where we set all the database connection details that we need. We provide a list of connection names here and refer to them in other files. The connection name default must be provided for database views (and DataSourceParameter , which will be mentioned later) that don't specify a connection name explicitly. Under default , change the url from sqlite://${username}:${password}@/./database/sample_database.db to sqlite:///./database/seattle_weather.db . The syntax for the URL uses sqlalchemy database URLs . Since sqlite databases don't require a username and password, the credential_key field can be omitted. More details on setting and using credential keys can be found on the pages for \" credential management \" command line reference and how to \" Configure Database Connections \". The db_connections section should now look like this: db_connections: default: url: 'sqlite:///./database/seattle_weather.db' Note The db_connections section is optional if you choose to set the connection details in Python with a connections.py file or if your squirrels project doesn't require any database connections. More details can be found on the \" Configure Database Connections \" page.","title":"Setting the Database Connections"},{"location":"tutorial/manifest/#defining-the-datasets","text":"This section is where we define the attributes for all datasets created by the squirrels project. Every dataset defined will have their own \"parameters API\" and \"dataset API\". Currently, there is one dataset with the name sample_dataset (and label Sample Dataset ). Change the name to weather_by_time , and change the label to Weather by Time of Year . Every dataset defined would have 0 or more database_views and exactly 1 final_view . Each of the database_views / final_view can either be A string for the file name of the SQL file (templated with Jinja ) or Python file to run, or An object with the file key and additional optional keys such as db_connection and args . In addition to being a templated SQL or Python file, the final_view can also be the name of one of the database views. Note At runtime, all the database views for the dataset are run in parallel. If the final view is a SQL file, all the database view results are loaded into an in-memory sqlite database where the table names are the same as the database view names. If the final view is a Python file, the database view results are accessible as a dictionary of database view names to pandas Dataframes. More details on writing final views will come later in the tutorial. Change the name database_view1 to aggregate_weather_metrics , and replace its value from an object to the string aggr_weather_metrics.sql.j2 . Change the value of final_view to final_view.sql.j2 . You may also remove the optional args key to the weather_by_time dataset. The datasets section should now look like this: datasets: weather_by_time: label: Weather by Time of Year database_views: aggregate_weather_metrics: aggr_weather_metrics.sql.j2 final_view: final_view.sql.j2 Every dataset that's set in the datasets section must also have a matching folder name in datasets folder. In the datasets folder, rename sample_dataset to weather_by_time .","title":"Defining the Datasets"},{"location":"tutorial/parameters/","text":"Create the Dataset Parameters Go into the parameters.py file in the weather_by_time dataset folder. This file contains the definitions of all the widget parameters used in the dataset through a main function. The possible widget parameter classes supported today are SingleSelectParameter , MultiSelectParameter , DateParameter , NumberParameter , and DataSourceParameter . The DataSourceParameter represents a parameter based on a lookup table in a database, and can convert itself into one of the other parameter types. The other parameter types should be self-explanatory. The classes (with constructors) are imported from the squirrels library, and all the widget parameter class constructors take name and label as required arguments. The name is what we use to reference the parameter in the dataset queries (as you'll see later in the tutorial), and it's also the name of the corresponding API query parameter. The label represents the human-readable display name to show on the user interface. Different parameter constructors have different required parameters, and most Python IDEs should be able to provide information on the required vs. optional parameters for each constructor. We will start from scratch, so remove all the existing code in the main function body. Define a Custom Class for Parameter Options We will create a single-select parameter called \"group_by\" which will allow us to aggregate our weather metrics by year, quarter, month, etc. After the imports (before the main function), we can create our own \"parameter option\" class by extending from the existing SelectParameterOption class from squirrels and defining our own attributes. Here is the class definition: class GroupByOption(sq.SelectParameterOption): def __init__(self, id, label, dim_col, order_by_col = None): super().__init__(id, label) self.dim_col = dim_col self.order_by_col = order_by_col if order_by_col is not None else dim_col The dim_col specifies the column name to group by, and the order_by_col lets us pick a column for ordering the results (or orders by dim_col if not specified). If we group by month for instance, we do not want to order by month name alphabetically. Define the Parameter Options Inside the main function, we can now use the new GroupByOption class to define a list of parameter options as such: group_by_options = [ GroupByOption('0', 'Year', 'year'), GroupByOption('1', 'Quarter', 'quarter'), GroupByOption('2', 'Month', 'month_name', 'month_order'), GroupByOption('3', 'Day of Year', 'day_of_year'), GroupByOption('4', 'Condition', 'condition') ] The first parameter to the constructor for each SelectParameterOption (or GroupByOption in this case) is an ID that must be distinct across options and would never change in the future. For example, once the API consumers associates ID \"0\" to mean \"group by year\" then that association should never be broken even if the label or the ordering of the dropdown options change. Note The SelectParameterOption class has an is_default attribute to specify the parameter option(s) that are selected by default. By default, is_default is set to False. When none of the parameter options have is_default as True, the first option becomes default for single select parameters. Define the Parameters The main function must return a ParameterSet (a class from the squirrels library), and it simply takes a list of Parameter objects. We can define our \"group_by_parameter\" as such: group_by_parameter = sq.SingleSelectParameter('group_by', 'Group By', group_by_options) Since this is the only parameter we are making for this dataset, we can return the parameter set like this: return sq.ParameterSet([group_by_parameter]) The contents of the parameters.py file should now look like this: from typing import Dict, Any import squirrels as sq class GroupByOption(sq.SelectParameterOption): def __init__(self, id, label, dim_col, order_by_col = None): super().__init__(id, label) self.dim_col = dim_col self.order_by_col = order_by_col if order_by_col is not None else dim_col def main(args: Dict[str, Any], *p_args, **kwargs) -> sq.ParameterSet: group_by_options = [ GroupByOption('0', 'Year', 'year'), GroupByOption('1', 'Quarter', 'quarter'), GroupByOption('2', 'Month', 'month_name', 'month_order'), GroupByOption('3', 'Day of Year', 'day_of_year'), GroupByOption('4', 'Condition', 'condition') ] group_by_parameter = sq.SingleSelectParameter('group_by', 'Group By', group_by_options) return sq.ParameterSet([group_by_parameter])","title":"3. Create the Dataset Parameters"},{"location":"tutorial/parameters/#create-the-dataset-parameters","text":"Go into the parameters.py file in the weather_by_time dataset folder. This file contains the definitions of all the widget parameters used in the dataset through a main function. The possible widget parameter classes supported today are SingleSelectParameter , MultiSelectParameter , DateParameter , NumberParameter , and DataSourceParameter . The DataSourceParameter represents a parameter based on a lookup table in a database, and can convert itself into one of the other parameter types. The other parameter types should be self-explanatory. The classes (with constructors) are imported from the squirrels library, and all the widget parameter class constructors take name and label as required arguments. The name is what we use to reference the parameter in the dataset queries (as you'll see later in the tutorial), and it's also the name of the corresponding API query parameter. The label represents the human-readable display name to show on the user interface. Different parameter constructors have different required parameters, and most Python IDEs should be able to provide information on the required vs. optional parameters for each constructor. We will start from scratch, so remove all the existing code in the main function body.","title":"Create the Dataset Parameters"},{"location":"tutorial/parameters/#define-a-custom-class-for-parameter-options","text":"We will create a single-select parameter called \"group_by\" which will allow us to aggregate our weather metrics by year, quarter, month, etc. After the imports (before the main function), we can create our own \"parameter option\" class by extending from the existing SelectParameterOption class from squirrels and defining our own attributes. Here is the class definition: class GroupByOption(sq.SelectParameterOption): def __init__(self, id, label, dim_col, order_by_col = None): super().__init__(id, label) self.dim_col = dim_col self.order_by_col = order_by_col if order_by_col is not None else dim_col The dim_col specifies the column name to group by, and the order_by_col lets us pick a column for ordering the results (or orders by dim_col if not specified). If we group by month for instance, we do not want to order by month name alphabetically.","title":"Define a Custom Class for Parameter Options"},{"location":"tutorial/parameters/#define-the-parameter-options","text":"Inside the main function, we can now use the new GroupByOption class to define a list of parameter options as such: group_by_options = [ GroupByOption('0', 'Year', 'year'), GroupByOption('1', 'Quarter', 'quarter'), GroupByOption('2', 'Month', 'month_name', 'month_order'), GroupByOption('3', 'Day of Year', 'day_of_year'), GroupByOption('4', 'Condition', 'condition') ] The first parameter to the constructor for each SelectParameterOption (or GroupByOption in this case) is an ID that must be distinct across options and would never change in the future. For example, once the API consumers associates ID \"0\" to mean \"group by year\" then that association should never be broken even if the label or the ordering of the dropdown options change. Note The SelectParameterOption class has an is_default attribute to specify the parameter option(s) that are selected by default. By default, is_default is set to False. When none of the parameter options have is_default as True, the first option becomes default for single select parameters.","title":"Define the Parameter Options"},{"location":"tutorial/parameters/#define-the-parameters","text":"The main function must return a ParameterSet (a class from the squirrels library), and it simply takes a list of Parameter objects. We can define our \"group_by_parameter\" as such: group_by_parameter = sq.SingleSelectParameter('group_by', 'Group By', group_by_options) Since this is the only parameter we are making for this dataset, we can return the parameter set like this: return sq.ParameterSet([group_by_parameter]) The contents of the parameters.py file should now look like this: from typing import Dict, Any import squirrels as sq class GroupByOption(sq.SelectParameterOption): def __init__(self, id, label, dim_col, order_by_col = None): super().__init__(id, label) self.dim_col = dim_col self.order_by_col = order_by_col if order_by_col is not None else dim_col def main(args: Dict[str, Any], *p_args, **kwargs) -> sq.ParameterSet: group_by_options = [ GroupByOption('0', 'Year', 'year'), GroupByOption('1', 'Quarter', 'quarter'), GroupByOption('2', 'Month', 'month_name', 'month_order'), GroupByOption('3', 'Day of Year', 'day_of_year'), GroupByOption('4', 'Condition', 'condition') ] group_by_parameter = sq.SingleSelectParameter('group_by', 'Group By', group_by_options) return sq.ParameterSet([group_by_parameter])","title":"Define the Parameters"},{"location":"tutorial/queries/","text":"Create the SQL Queries In the weather_by_time dataset folder, rename database_view1.sql.j2 to aggr_weather_metrics.sql.j2 . The final_view.sql.j2 file name can remain the same. In these files, we will write the analytical sql query to return tabular results for the dataset. These sql query can be templated using Jinja, with access to the prms , ctx , and args variables which stand for \"ParameterSet\", \"Context\", and \"Arguments\" respectively. More information about these variables can be found in the \" Create Views with SQL and Jinja \" page. For now, just know that we can access the selected parameter value(s) by using prms[\"parameter name\"] in Jinja. Define the Database View In aggr_weather_metrics.sql.j2 , change its contents to the following: {% set selected_group_by = prms[\"group_by\"].get_selected() -%} {% set dim_col = selected_group_by.dim_col -%} {% set order_col = selected_group_by.order_by_col -%} SELECT {{ dim_col }} , {{ order_col }} as ordering , avg(temp_max) as temperature_high_C , avg(temp_min) as temperature_low_C , avg(precipitation) as precipitation_inches , avg(wind) as wind_mph FROM weather GROUP BY {{ dim_col }}, {{ order_col }} This query finds the average temperature, precipitation level, and wind speed by year, or by year of month, or by day of year, etc. based the selected value of the group_by parameter. The set keyword is Jinja syntax for assigning variables. The prms['group_by'] returns a SingleSelectParameter (as we previously defined in parameters.py ), which contains the method .get_selected() for getting the ParameterOption object (or more specifically, a GroupByOption object). Since we've defined the attributes dim_col and order_by_col in the GroupByOption class, we know we can access them from the selected_group_by variable above. Define the Final View In final_view.sql.j2 , change its contents to the following: {% set selected_group_by = prms[\"group_by\"].get_selected() -%} {% set dim_col = selected_group_by.dim_col -%} SELECT {{ dim_col }} , temperature_high_C , temperature_low_C , precipitation_inches , wind_mph FROM aggregate_weather_metrics ORDER BY ordering A few things to notice here: The table aggregate_weather_metrics in the \"FROM\" clause is the name of the database view we defined in aggr_weather_metrics.sql.j2 . The name was specified in squirrels.yaml . In this query, we are selecting all columns except the ordering column, which is what we use in the \"ORDER BY\" clause instead. The first two lines where we set the selected_group_by and dim_col variables are repeated with the database view file. The repetition can be avoided either by using Jinja's include/import , or by using a context.py file which will be discussed later in the tutorial.","title":"4. Create the SQL Queries"},{"location":"tutorial/queries/#create-the-sql-queries","text":"In the weather_by_time dataset folder, rename database_view1.sql.j2 to aggr_weather_metrics.sql.j2 . The final_view.sql.j2 file name can remain the same. In these files, we will write the analytical sql query to return tabular results for the dataset. These sql query can be templated using Jinja, with access to the prms , ctx , and args variables which stand for \"ParameterSet\", \"Context\", and \"Arguments\" respectively. More information about these variables can be found in the \" Create Views with SQL and Jinja \" page. For now, just know that we can access the selected parameter value(s) by using prms[\"parameter name\"] in Jinja.","title":"Create the SQL Queries"},{"location":"tutorial/queries/#define-the-database-view","text":"In aggr_weather_metrics.sql.j2 , change its contents to the following: {% set selected_group_by = prms[\"group_by\"].get_selected() -%} {% set dim_col = selected_group_by.dim_col -%} {% set order_col = selected_group_by.order_by_col -%} SELECT {{ dim_col }} , {{ order_col }} as ordering , avg(temp_max) as temperature_high_C , avg(temp_min) as temperature_low_C , avg(precipitation) as precipitation_inches , avg(wind) as wind_mph FROM weather GROUP BY {{ dim_col }}, {{ order_col }} This query finds the average temperature, precipitation level, and wind speed by year, or by year of month, or by day of year, etc. based the selected value of the group_by parameter. The set keyword is Jinja syntax for assigning variables. The prms['group_by'] returns a SingleSelectParameter (as we previously defined in parameters.py ), which contains the method .get_selected() for getting the ParameterOption object (or more specifically, a GroupByOption object). Since we've defined the attributes dim_col and order_by_col in the GroupByOption class, we know we can access them from the selected_group_by variable above.","title":"Define the Database View"},{"location":"tutorial/queries/#define-the-final-view","text":"In final_view.sql.j2 , change its contents to the following: {% set selected_group_by = prms[\"group_by\"].get_selected() -%} {% set dim_col = selected_group_by.dim_col -%} SELECT {{ dim_col }} , temperature_high_C , temperature_low_C , precipitation_inches , wind_mph FROM aggregate_weather_metrics ORDER BY ordering A few things to notice here: The table aggregate_weather_metrics in the \"FROM\" clause is the name of the database view we defined in aggr_weather_metrics.sql.j2 . The name was specified in squirrels.yaml . In this query, we are selecting all columns except the ordering column, which is what we use in the \"ORDER BY\" clause instead. The first two lines where we set the selected_group_by and dim_col variables are repeated with the database view file. The repetition can be avoided either by using Jinja's include/import , or by using a context.py file which will be discussed later in the tutorial.","title":"Define the Final View"},{"location":"tutorial/testapi/","text":"Activate the REST APIs & Test In the weather_by_time datasets folder, go into context.py and replace the body of the main function to: return {} We will discuss the context.py file later in the tutorial. For now, we are changing it to return an empty dictionary such that we can activate the REST APIs without errors. To activate the API server, simply run: squirrels run --debug Note The --debug argument is optional here. This is specified to be able to test with hidden parameters, though no hidden parameters were set up for this tutorial. See squirrels run --help or the \" run command line \" page for more details. Then, in a web browser, go to http://localhost:8000/ to interact with the dataset APIs you've just created using the Squirrels UI! Test the Rendered SQL Queries In practice, you may wish to review what the rendered SQL queries look like (for some set of parameter selections) before actually running the queries. To do this for the weather_by_time dataset (using the default parameter selections), run: squirrels test weather_by_time This creates the folder path outputs/weather_by_time with the generated SQL queries (without actually running them). Confirm all output files look as expected. We can also use the following to run the generated queries as well and generate the database views / final view as csv files. squirrels test weather_by_time --runquery We can also test on non-default parameter selections. In the dataset folder, change the contents of the selections.cfg file to: [parameters] group_by = 2 When we define multiple parameters, the order of the parameters specifed here must be the same as the order as defined in the parameters.py file (especially if cascading parameters exist). The \"2\" represents selecting the \"Month\" option for the group_by parameter. Run the following to render the SQL queries with selections.cfg : squirrels test weather_by_time --cfg selections.cfg See squirrels test --help or the page for the \" test command line \" for more details.","title":"5. Activate the REST APIs & Test"},{"location":"tutorial/testapi/#activate-the-rest-apis-test","text":"In the weather_by_time datasets folder, go into context.py and replace the body of the main function to: return {} We will discuss the context.py file later in the tutorial. For now, we are changing it to return an empty dictionary such that we can activate the REST APIs without errors. To activate the API server, simply run: squirrels run --debug Note The --debug argument is optional here. This is specified to be able to test with hidden parameters, though no hidden parameters were set up for this tutorial. See squirrels run --help or the \" run command line \" page for more details. Then, in a web browser, go to http://localhost:8000/ to interact with the dataset APIs you've just created using the Squirrels UI!","title":"Activate the REST APIs &amp; Test"},{"location":"tutorial/testapi/#test-the-rendered-sql-queries","text":"In practice, you may wish to review what the rendered SQL queries look like (for some set of parameter selections) before actually running the queries. To do this for the weather_by_time dataset (using the default parameter selections), run: squirrels test weather_by_time This creates the folder path outputs/weather_by_time with the generated SQL queries (without actually running them). Confirm all output files look as expected. We can also use the following to run the generated queries as well and generate the database views / final view as csv files. squirrels test weather_by_time --runquery We can also test on non-default parameter selections. In the dataset folder, change the contents of the selections.cfg file to: [parameters] group_by = 2 When we define multiple parameters, the order of the parameters specifed here must be the same as the order as defined in the parameters.py file (especially if cascading parameters exist). The \"2\" represents selecting the \"Month\" option for the group_by parameter. Run the following to render the SQL queries with selections.cfg : squirrels test weather_by_time --cfg selections.cfg See squirrels test --help or the page for the \" test command line \" for more details.","title":"Test the Rendered SQL Queries"}]}